状态行为如何随机
- 状态行为转移trans-action
  trans-action1: 4.2 adv 
```python
class AdvTrans(BaseTrans):
    STATE = ['IDLE', 'STOP', 'START']
    TRANS_ACTION: dict[int, list[int | str | None]] = {
        #  IDLE                 STOP                  START
        0: [None,                         2,        'start_adv'],     # IDLE
        1: ['clear_adv', 'set_adv_raw_data',        'start_adv'],     # STOP
        2: [1,                   'stop_adv', 'set_adv_raw_data']      # START
    }
```

  trans-action2: 4.2 scan [代码待补充]
```python
class ScanTrans(BaseTrans):
    STATE = ['IDLE', 'START']
    TRANS_ACTION: dict = {
        #   IDLE            START
        0: [None,       'start_scan'],     # IDLE
        1: ['stop_scan',        None],     # START
    }
```  
- 下一个随机状态如何确定

- 两端交互 - 测试端&配合端


参数如何随机
- 参数随机范围(测试端)
```c
class AdvParam(BaseParam):
    PARAM_RANGES: Dict[str, Tuple[int, int] | List[int]] = {
        'own_addr_type': [0, 1, 2, 3],    # 0=公共地址, 1=随机地址, 2=解析的私有地址, 3=未解析的私有地址
        'peer_addr_type': [0, 1],   # 0=公共地址, 1=随机地址
        'adv_type': (0, 4),         # 0=可连接可扫描, 1=可连接不可扫描, 2=不可连接可扫描, 3=不可连接不可扫描, 4=扫描响应
        'interval': (0x20, 0x4000), # 广播间隔: 12.5ms-6400ms (单位: 0.625ms)
        'channel_map': (0, 7),      # 通道映射: bit0=37信道, bit1=38信道, bit2=39信道
        'duration': (0, 65),        # 广播持续时间: 0=无限, 1-65秒
        'filter_policy': (0, 3),    # 0=处理所有扫描和连接请求, 1=处理白名单设备的扫描请求, 2=处理白名单设备的连接请求, 3=处理白名单设备的扫描和连接请求
        'set_adv_type': [1, 2, 3],  # 设置广播数据类型: 1=广播数据, 2=扫描响应数据, 3=两者
        'raw_data_len': (0, 31),    # 数据长度: 0-31字节
        # 'adv_handle': (0, 0xEF),    # 广播句柄: 0x00-0xEF
        # 'adv_max_skip': (0, 255),   # 最大跳过事件数
    }
``` 
```c
class ScanParam(BaseParam):
    PARAM_RANGES: Dict[str, Tuple[int, int] | List[int]] = {
        'own_addr_type': (0, 3),        # 0=公共地址, 1=随机地址, 2=解析的私有地址, 3=未解析的私有地址
        'scan_type': [0, 1],            # 扫描类型: 0=被动扫描, 1=主动扫描
        'scan_interval': (4, 0x4000),   # 扫描间隔: 2.5ms-10240ms (单位: 0.625ms)
        'scan_window': (10, 100),       # 扫描占空比: 10%-100% (单位: 0.625ms)
        'scan_filter_policy': (0, 3),   # 扫描过滤策略
        'scan_duplicate': [0, 1],       # 重复扫描: 0=不重复, 1=重复
        'timeout': (0, 65),             # 超时时间: 0-65 秒
        'config_index': [0, 1],         # 配置索引: 0=主动扫描配置, 1=被动扫描配置
    }
```  
- 配合端参数如何确定
    每次根据测试端参数算出一组对应的配合端参数
    - adv作测试端 scan作被测端 scan端参数计算[举例补充 - 注意scan period duration interval window作为被测端时的计算]
    - scan作测试端 adv作被测端 adv端参数计算[举例补充]

- 参数如何随机生成
- 参数组合规则


- 状态和参数保存(下发的参数/执行时的状态)
    - 下发参数每次存储到外部文件中
    - 执行时的状态存储在DutInfo中，时时更新，teardown时清除


若过程中出现执行失败情况，采取的teardown方式
正确率控制 - 暂时先不考虑错误情况，下一版优化的时候再说









目录
状态行为如何随机
- 状态行为转移trans-action
  trans-action1: 4.2 adv
  trans-action2: 4.2 scan
- 下一个随机状态如何确定
- 两端交互 - 测试端&配合端

参数如何随机
- 参数随机范围(测试端)
- 配合端参数如何确定
    每次根据测试端参数算出一组对应的配合端参数
    - adv作测试端 scan作被测端 scan端参数计算
    - scan作测试端 adv作被测端 adv端参数计算
- 参数如何随机生成
- 参数组合规则
- 状态和参数保存(下发的参数/执行时的状态)
其他问题
- 若过程中出现执行失败情况，采取的teardown方式
- 正确率控制 - 暂时先不考虑错误情况，下一版优化的时候再说



```python
"""返回结果参数集合"""
def lay2_func_name(self, dut_name: str, module: str, action: str, expected_res: bool, params: dict = None) -> dict

```



12.15 TODO:

    梳理随机模式细节


12.16 TODO

    梳理随机模式细节
    迁移VNC feature/new_framework到新仓库
    组织随机模式细节讨论会议：讨论并优化随机模式实现方式
    最新随机模式实现流程图
    随机模式配合端指令怎么下发在哪儿下发，配合端如何配合测试端
    ...备忘录内容抄上来


12.17

    迁移外部feature/new_framework到VNC新仓库并跑通
    新框架log系统